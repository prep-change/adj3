<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>釣銭準備</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 p-4 text-sm">

  <h1 class="text-xl font-bold mb-4">釣銭準備</h1>

  <form id="form" class="space-y-4">
    <div class="grid grid-cols-3 gap-2">
      <label class="font-semibold">金種</label>
      <label class="font-semibold">在庫</label>
      <label class="font-semibold">希望枚数</label>

      <!-- 金種ごとに入力欄を生成 -->
      ${[10000, 5000, 1000, 500, 100, 50, 10, 5, 1].map(denom => `
        <label>${denom}円</label>
        <input type="number" name="stock_${denom}" class="border rounded px-2 py-1" value="0" min="0"/>
        <input type="number" name="target_${denom}" class="border rounded px-2 py-1" value="0" min="0"/>
      `).join('')}
    </div>

    <div>
      <label class="block font-semibold mb-1">不足金種の増加候補から除外する金種：</label>
      <div class="flex flex-wrap gap-2">
        ${[10000, 5000, 1000, 500, 100, 50, 10, 5, 1].map(denom => `
          <label class="inline-flex items-center">
            <input type="checkbox" name="exclude" value="${denom}" class="mr-1"/>
            ${denom}円
          </label>
        `).join('')}
      </div>
    </div>

    <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
      計算する
    </button>
  </form>

  <div id="result" class="mt-6 whitespace-pre-wrap font-mono text-sm text-gray-800"></div>

  <script>
    const fixedTotal = 155600;

    document.getElementById('form').addEventListener('submit', (e) => {
      e.preventDefault();
      const form = new FormData(e.target);
      const stocks = {}, targets = {};
      const exclude = [];

      form.forEach((value, key) => {
        if (key.startsWith('stock_')) {
          const denom = Number(key.replace('stock_', ''));
          stocks[denom] = Number(value);
        } else if (key.startsWith('target_')) {
          const denom = Number(key.replace('target_', ''));
          targets[denom] = Number(value);
        } else if (key === 'exclude') {
          exclude.push(Number(value));
        }
      });

      const inputTotal = Object.entries(targets).reduce((sum, [d, n]) => sum + d * n, 0);
      const shortage = Object.fromEntries(Object.entries(targets).filter(([d, n]) => n > stocks[d]));

      const shortageTotal = Object.entries(shortage).reduce((sum, [d, n]) =>
        sum + (n - stocks[d]) * d, 0
      );

      const resultDiv = document.getElementById('result');
      resultDiv.innerText = '調整中...';

      setTimeout(() => {
        const patterns = generateAdjustmentPatterns(shortage, exclude, 5); // 最大5枚まで調整
        const adjusted = findBestPattern(patterns, stocks, fixedTotal);
        if (!adjusted) {
          resultDiv.innerText = '調整できませんでした。';
          return;
        }

        const diffs = Object.entries(adjusted).filter(([d, n]) => n > shortage[d]);
        const supplement = calculateSupplement(stocks, adjusted);

        let output = `不足金額：${shortageTotal.toLocaleString()}円\n\n`;
        output += '→ 不足を補うために以下を増加:\n';
        diffs.forEach(([d, n]) => {
          output += `  ${d}円 × ${(n - shortage[d])}枚\n`;
        });

        output += '\n→ 補填に使用した金種:\n';
        Object.entries(supplement).forEach(([d, n]) => {
          if (n > 0) output += `  ${d}円 × ${n}枚\n`;
        });

        resultDiv.innerText = output;
      }, 50);
    });

    function generateAdjustmentPatterns(baseTargets, excludeFromIncrease, extraCount) {
      const patterns = [];
      const denoms = Object.keys(baseTargets).map(Number);

      function backtrack(i, remaining, current) {
        if (i === denoms.length) {
          if (remaining === 0) patterns.push({ ...current });
          return;
        }
        const denom = denoms[i];
        const limit = excludeFromIncrease.includes(denom)
          ? 0
          : (denom === 5000 ? Math.min(1, remaining) : remaining);

        for (let add = 0; add <= limit; add++) {
          current[denom] = baseTargets[denom] + add;
          backtrack(i + 1, remaining - add, current);
        }
      }

      backtrack(0, extraCount, {});
      return patterns;
    }

    function calculateSupplement(stocks, targets) {
      let remain = Object.entries(targets).reduce((sum, [d, n]) => sum + d * n, 0)
                 - Object.entries(stocks).reduce((sum, [d, n]) => sum + d * n, 0);
      const supplement = {};
      const denoms = Object.keys(stocks).map(Number).sort((a, b) => b - a);

      for (const d of denoms) {
        const available = stocks[d];
        const use = Math.min(Math.floor(remain / d), available);
        supplement[d] = use;
        remain -= use * d;
      }
      return supplement;
    }

    function findBestPattern(patterns, stocks, totalTarget) {
      return patterns.find(pattern => {
        const total = Object.entries(pattern).reduce((sum, [d, n]) => sum + d * n, 0);
        if (total !== totalTarget) return false;

        const supplement = calculateSupplement(stocks, pattern);
        const supplied = Object.entries(supplement).reduce((sum, [d, n]) => sum + d * n, 0);
        const needed = Object.entries(pattern).reduce((sum, [d, n]) => sum + d * n, 0)
                    - Object.entries(stocks).reduce((sum, [d, n]) => sum + d * n, 0);
        return supplied >= needed;
      });
    }
  </script>
</body>
</html>
